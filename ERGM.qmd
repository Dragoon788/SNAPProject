#Attempt 1 at this ERGM and vis!


```{r}
#| echo: false
#| output: false
#| message: false

rm(list=ls())

# Lab 3:
# Exponential Random Graph Models (ERGMs)

# Clear your environment
rm(list=ls())

# Install packages below if you do not have them:
# -------------------------------------------------
if (!"statnet" %in% installed.packages()) install.packages("statnet") # For fitting ERGMs
if (!"igraph" %in% installed.packages()) install.packages("igraph") # For network plotting
if (!"texreg" %in% installed.packages()) install.packages("texreg") # For printing "nicer" model output

library(statnet)

# -------------------------------------------------------------------------------------------------
# Set the working directory
# Session > Set Working Directory > To Source File Location
# -------------------------------------------------------------------------------------------------
list.files() # List the files in the current working directory to see if you're in the right directory

```

```{r}
#| echo: false
#| output: false
#| message: false

######################## PART I: Building and Visualizing the Networks ########################
# ----------------------------------------------------------------------------------------------------
# Dependent variable:
# Responses to the question:
#weight is the overlapping viewers!
ov_viewerEdgelist <- read.csv("Updated&Cleaned-Edgelist.csv")
# View the first rows of the edgelist to make sure it imported correctly:
head(ov_viewerEdgelist)

# Convert the edgelist to a network object in statnet format:
overlap_view <- as.network.matrix(ov_viewerEdgelist, matrix.type = "edgelist")
# View a summary of the network object
overlap_view

# Independent variables:
# Load node attributes, and store them in the advice network object we have created
overlap_view |> network::set.vertex.attribute("Channel_Name",
                          value = read.csv("new_updated_channels_with_count.csv")$Channel_Name) # Categorical variable for channel name. I dont think this one is all that neccesary since they are all unique values but you never know so I added it in lol

overlap_view |> network::set.vertex.attribute("Language",
                          value = read.csv("new_updated_channels_with_count.csv")$Language) # Categorical variable for lang

overlap_view |> network::set.vertex.attribute("Tags",
                          value = read.csv("new_updated_channels_with_count.csv")$Tags) # Categorical variable for tags

overlap_view |> network::set.vertex.attribute("Last_Played_Game",
                          value = read.csv("new_updated_channels_with_count.csv")$Last_Played_Game)
# Last game played

overlap_view |> network::set.vertex.attribute("Game_ID",
                          value = read.csv("new_updated_channels_with_count.csv")$`Game_ID`) # Categorical variable for Game ID, The ID of the game that the user plays. The game is not updated if the ID isnâ€™t a game ID that Twitch recognizes.

overlap_view |> network::set.vertex.attribute("ChannelID",
                          value = read.csv("new_updated_channels_with_count.csv")$ChannelID)
#Channel_ID = Unique ID given to each user

overlap_view |> network::set.vertex.attribute("Count",
                          value = read.csv("new_updated_channels_with_count.csv")$Count)
# Count = number of unique viewers

overlap_view |> network::set.vertex.attribute("followers",
                          value = read.csv("new_updated_channels_with_count.csv")$followers) #with followers


overlap_view # These 8 variables should now be listed as vertex attributes when viewing the summary of the network
```
```{r}
# # Double-check the values for all of the node variables
#### Note: looks good to me! It's just a lot so I commented it out!

# network::get.vertex.attribute(overlap_view,"Channel_Name")
# network::get.vertex.attribute(overlap_view,"Tags")
# network::get.vertex.attribute(overlap_view,"Language")
# network::get.vertex.attribute(overlap_view,"Last_Played_Game")
# network::get.vertex.attribute(overlap_view,"Game_ID")
# network::get.vertex.attribute(overlap_view,"ChannelID")
# network::get.vertex.attribute(overlap_view,"Count")
# network::get.vertex.attribute(overlap_view,"followers")
```


##VIS WILL GO HERE WHERE THE TEAMMATES DO ITTTTT


**LET ME KNOW IF YALL THINK ANYTHING ELSE ATTRIBUTE LOOKING INTO WISE SHOULD BE ADDED IN HERE!!! WORK ON NODEICOV LATERRR**
```{r}
# ----------------------------------------------------------------------------
######################## PART II: Build the ERGM models ########################
#
# R vignette for more details: https://cran.r-project.org/web/packages/ergm/ergm.pdf
# ----------------------------------------------------------------------------
#detach(package:igraph) # Remove the 'igraph' package from your environment. 
library(statnet)
options(ergm.loglik.warn_dyads=FALSE) #Whether or not a warning should be issued when sample space constraints render the observed number of dyads ill-defined

# Ergm Terms are statistics: They are some deterministic function of the ties, node attributes, and edge covariates of a network.
help("ergm-terms",package = "ergm") # Documentation that contains definitions for all of the terms we are using
                                    # ex. what does "mutual" test and how is it calculated
# We will use the ergm-terms to perform hypothesis testing using ERGMs
# But we can note that any of the ERGM terms can also be examined directly for your observed network, by creating a formula in R

# Look at Endogenous statistics: terms based on only ties in the advice network
summary(overlap_view ~ edges)                     # Number of edges (ties)
#dont really need mutual, the ties are not too likely to be mutual
summary(overlap_view ~ odegree(0:10))              # Outdegree distribution. (# of nodes with outdegree of 0, # nodes outdegree of 1, etc., playing with this number, will increase to 10 from 5 (7:19pm 8/21))
                                           
summary(overlap_view ~ idegree(0:100))             # Indegree distribution. (increased to 100 from 65, will decide later whether to increase it more!)
summary(overlap_view ~ gwodegree(log(2),fixed=T)) # One parameter summarizing outdegree distribution - tendency against outdegree hubs
summary(overlap_view ~ gwidegree(log(2),fixed=T)) # One parameters summarizing indegree distribution - tendency against indegree hubs
summary(overlap_view ~ desp(1:10))                 # Pairs of nodes with one shared partner, two shared partners, etc. (increasing up from 5 to 10 shared partners!)
summary(overlap_view ~ dgwesp(log(2),fixed = T))  # One parameter summarizing 

# Look at Exogenous statistics: terms based on advice ties AND other ties / node attributes

# summary(overlap_view ~ nodeicov("Tags"))             # Evaluates how the presence of different tags affects the likelihood of nodes forming connections
# #   #I WOULD HAVE TO CREAT DUMMY VARS FOR THIS!!!!!! SHOULD I DO THAT??

# summary(overlap_view ~ nodeicov("Game_ID"))             # assess how 'Game_ID' attribute affect the likelihood of nodes forming connections (the gameid goes with the last game they played)
# ###Should I remove this one??
# #   #I WOULD HAVE TO CREAT DUMMY VARS FOR THIS!!!!!! SHOULD I DO THAT??

summary(overlap_view ~ nodeocov("Count"))             #examines whether nodes with different values of the Count attribute (number of unique viewers) have varying probabilities of being connected to other nodes. Helps determine if nodes with higher or lower viewer counts are more or less likely to have edges between them.

summary(overlap_view ~ nodematch("Language"))            # Number of ties between users of same language
#Note: Note sure if as important but will see

summary(overlap_view ~ nodematch("Tags"))        # Number of ties between users of the same tag

summary(overlap_view ~ nodematch("Last_Played_Game"))        # Number of ties between people who have the same last game played

summary(overlap_view ~ nodeicov("followers"))        #assess whether users with higher follower counts are more likely to receive connections from others.

summary(overlap_view ~ nodeocov("followers"))      
```
#SPACE FOR MOD SCORE DESCRIPTIVE ANYLITICS AND VIS FOR IT

#SPACE FOR Betweenness Centrality & Bridge Detection Algorithms DESCPRITIVE ANYLITICS AND BRIDGE DETECTION

#simple model; a complex model attempt was made but no progress
```{r}
#adding in things like gwidegree, gwodegree, gwodegree, dgwesp is too complex for the model right now
model_simple <- ergm(overlap_view ~ edges 
                     + nodeocov("followers")
                     + nodeicov("followers")
                     + nodeocov("Count") # Covariance between out-degree of nodes and attributes of nodes
                     + nodematch("Language") # Homophily on lang
                     + nodematch("Tags")  #Homophily on tags
                     + nodematch("Last_Played_Game") #Homophily on last played games
               # Control settings for MCMC-MLE algorithm
               , constraints =~ bd(maxout= 100000000) #it wont be an mcmc without me doing this weirdly high value
               , control = control.ergm(MCMC.effectiveSize = 50,
                                        seed = 42)
)
summary(model_simple)
```

#model diagnostics for simple model
```{r}
par(mar=c(2,2,2,2))
mcmc.diagnostics(model_simple)
```

#Prep for t-test (will delete later)
```{r}
#| warning: false
# -------------------------------------------------------------------------------------------------
# Goodness of fit test - will display in RStudio
# Check how well the estimated model captures certain features of the observed network, for example triangles in the network.
# -------------------------------------------------------------------------------------------------
library('igraph')

overlap_view_igraph <- graph.adjacency(as.matrix.network(overlap_view)) # make an igraph network object from statnet network object
#overlap_view_igraph <- set_vertex_attr(overlap_view_igraph,"female",value = read.csv("femaleNode.csv")$female)
net_layout <- layout_with_fr(overlap_view_igraph) # Calculates and stores a spring-embedded layout
                                           # We will re-use this same layout for each plot, so nodes are always in the same place

sim <- simulate(model_simple, burnin=100000, interval=100000, nsim=50, verbose=T)  # Uses the ergm model to simulate a null model
# Plot the first of the simulated networks
sim_net1 <- igraph::graph.adjacency(as.matrix.network(sim[[1]]))
igraph::plot.igraph(sim_net1,layout=net_layout,edge.color="grey",  
                    vertex.color = 'grey',edge.arrow.size=.1)                                                               
# Plot the 10th simulated network
sim_net10 <- igraph::graph.adjacency(as.matrix.network(sim[[10]]))
igraph::plot.igraph(sim_net10,layout=net_layout,edge.color="purple",  
                    vertex.color = 'grey',edge.arrow.size=.1)
```


#T-test (will delete later)
```{r}
# Model 2:
model_simple.tridist <- sapply(1:50, function(x) summary(sim[[x]] ~triangle)) # Extracts the triangle data from the simulated networks
hist(model_simple.tridist,xlim=c(0,1000),breaks=10)  

overlap_view.tri <- summary(overlap_view ~ triangle)                                    # Stores the number of observed triangles
overlap_view.tri

# Plots that triangle distribution as a histogram, change xlim to change the x-axis range if necessary
arrows(overlap_view.tri,20, overlap_view.tri, 0.5, col="red", lwd=3)                    # Adds an arrow to the plotted histogram
c(obs=overlap_view.tri,mean=mean(model_simple.tridist),sd=sd(model_simple.tridist),
  tstat=abs(mean(model_simple.tridist)-overlap_view.tri)/sd(model_simple.tridist))
```
**Note: Not sure if I did this wrong but my t-stat is extremely bad (2307.520), not sure what I did wrong and the histogram is not showing up**

#goodness of fit 
```{r}
#| warning: false
# Model 2:
# It may take a second for this command to run.
gof1 <- gof(model_simple, verbose=T, burnin=1e+5, interval=1e+5, control = control.gof.ergm(nsim = 50))
# If you run below and then wouldn't see the plot, try par(mar=c(2,2,2,2))
#dev.off()
plot(gof1)
gof1
```